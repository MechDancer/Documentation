{"meta":{"title":"MechDancer Documentation","subtitle":null,"description":null,"author":"MechDancer","url":"https://www.mechdancer.org","root":"/Documentation/"},"pages":[],"posts":[{"title":"Dataflow","slug":"dataflow","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"dataflow/","link":"","permalink":"https://www.mechdancer.org/dataflow/","excerpt":"","text":"Abstractdataflow library provides components and tools to build data processing network, to help programmer build robust, concurrency-enabled applications easily. In other words, users do not need to manually manage task scheduling, even avoid all races under a premise of following certain design specifications and ensure the security of concurrent applications without mutex. Use caseUnlike traditional imperative programming, programmers who receive data flow ideas write programs by directly describing static data calculation sequences and data transfer relationships. Here is an example: 123456789101112fun main() = runBlocking &#123; // initialize val source = broadcast&lt;Int&gt;() source - &#123; println(it) &#125; source - &#123; 2 * it &#125; - &#123; println(it) &#125; // using source post 1 // waiting delay(100)&#125; In this example, the initialization code section describes a network with 4 nodes: A source node, who transfers number to two child nodes simultaneously A action node, print the number A transform node, double the number Another action node, print the doubled number In the code that follows, we post a number 1 to the source node. There will be a 1 and a 2 printout on the console. Normally 1 will appear before 2, but not absolute, because the dataflow library has parallelized these two actions. By parallelization, we can make full use of the CPU’s computing performance, in the low-frequency multi-core architecture of the mobile phone CPU, the benefits brought by parallelization are particularly obvious. Building network construction directly helps programmers better organize logic and avoid the confusion caused by repeated multi-layered function calls and multiple control transferring. The disposable, unsupervised execution style avoids the complexity of process control, and the data flowing between nodes can be considered constant, so that arbitrarily modifying the data at the later stage will not pose a danger to the predecessor. TerminologyThere are some important concepts in the dataflow library: Node Unlike the parallelized list operation supported by the standard libraries of many languages, dataflow provides coarse-grained parallelism, and nodes are atoms during the parallelization. The node is where the calculation takes place, and the data passing through the node is modified to change their value and type. In addition, unlike the imperative functions which do not manage the returned values at all, nodes also control the way that data is distributed backwards. According to the behavior of the data entering the node, nodes can be divided into buffed and unbuffered. According to the operation of data in the node, nodes can be divided into modified and unmodified. According to the way the data leaves the node, nodes can be divided into cold, normal and broadcast. Link The links connect nodes and become channels for the data. The data passed through the link can be filtered and counted according to some rules. Post Data can be passed automatically between nodes in the network, but usually the node will only process the data from other nodes and pass it backwards instead of generating the data itself. The operation to send external data to the network to start processing is called “post”. ImplementationThere are various ways to implement dataflow. The way we selected is to combine the responsive and producer consumer models, that is, the producer informs the consumer when the data is ready, and the consumer requests data from the producer when it is ready to process the data. The producer receives data from outside the network or other nodes, processes it, and then binds an id with the processed data, then informs the consumers it connected to with the id. The consumer immediately saves the id and uses the id to get corresponding data from the producer when it is ready to process it. If the data is still there (not consumed by other consumers and not discarded by the producer), the producer gives the data to the consumer. At which point the consumer becomes a producer, so the above steps will continue.","categories":[],"tags":[]},{"title":"Dependency","slug":"dependency","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"dependency/","link":"","permalink":"https://www.mechdancer.org/dependency/","excerpt":"","text":"Abstractdependency is an abstraction of dynamic component lookup. Through defining a series of interfaces, it standardizes the definition of weak coupling for components (global resources or functional modules) depending each other in projects. Some operations are provided for developers to setup a component into dynamic scope concurrently, and identify component dependencies. OverviewDefinitionsComponent1234567interface Component &#123; override fun equals(other: Any?): Boolean override fun hashCode(): Int &#125; The core of this project, which classes should mark with, can be added to a DynamicScope. All dependencies are put in a hash set, thus developers can deal with conflict problems by overriding following two functions: equals() and hashCode(). Dependent12345interface Dependent : Component &#123; fun sync(dependency: Component): Boolean &#125; Dependents are a kind of component that want to depends other components, i.e. find other components in the scope. sync() of dependents that haven’t found dependencies yet will be called. It passes in a new dependency, dependencies can check whether this new dependency is what it’s waiting, or save dependency’s reference, get some information etc. Meanwhile, dependents should return if they are concerned about other components passed in later, which is commonly used for marking this dependent has already got all dependencies. Dynamic scope1234567891011open class DynamicScope &#123; private val dependents : MutableList&lt;...&gt; = ... val components : Set&lt;Component&gt; = ... open infix fun setup(component: Component): Boolean = ... &#125; Dynamic scope is an aggregate of components bearing relationships between components. When a new component is set up, components will be updated, and those marked with Dependent will be notified of updating dependencies by calling theirs sync(). Developers can call setup() to add a component into this scope, which returns false if there is a conflict problem occurred. Abstract componentsFor easy of use, those two abstract class are defined: UniqueComponent NamedComponent The reason why UniqueComponent is named so is that it has a unique type in the dynamic scope, and it uses its Class as the symbol while checking conflicts. Similar to UniqueComponent, NamedComponent has a unique name as the symbol. Since then, developers can provide a type to get aUniqueComponent or a name to get a NamedComponent in the dynamic scope. Dependency managerOnce we have components mentioned above, providing parameters traversal components collection in dynamic scope for lookup some dependencies will be pretty common. Furthermore, developers should write a bunch of duplicated code in sync() if they want to use function provided by Dependent: 123456789101112131415161718class Apple : UniqueComponent&lt;Apple&gt;()class Banana : UniqueComponent&lt;Banana&gt;()class Cherry : UniqueComponent&lt;Cherry&gt;()class FruitBasket : UniqueComponent&lt;FruitBasket&gt;(), Dependent &#123; private lateinit var apple: Apple private lateinit var banana: Banana private lateinit var cherry: Cherry override fun sync(dependency: Component): Boolean &#123; when (dependency) &#123; is Apple -&gt; apple = dependency is Banana -&gt; banana = dependency is Cherry -&gt; cherry = dependency &#125; return ::apple.isInitialized &amp;&amp; ::banana.isInitialized &amp;&amp; ::cherry.isInitialized &#125;&#125; FruitBasket depends on Apple, Banana and Cherry. sync() should be written as above to get dependencies in the scope. DependencyManager can help to optimize code like this: 123456789101112131415class Apple : UniqueComponent&lt;Apple&gt;()class Banana : UniqueComponent&lt;Banana&gt;()class Cherry : UniqueComponent&lt;Cherry&gt;()class FruitBasket : UniqueComponent&lt;FruitBasket&gt;(), Dependent &#123; private val dependencyManager = DependencyManager() private val apple: Apple by dependencyManager.must() private val banana: Banana by dependencyManager.must() private val cherry: Cherry by dependencyManager.must() override fun sync(dependency: Component): Boolean = dependencyManager.sync(dependency)&#125; Moreover, DependencyManager provides powerful functions, please see use cases for details. Use cases remote standalonetc","categories":[],"tags":[]},{"title":"MechDancer Lib","slug":"mechdancerlib","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"mechdancerlib/","link":"","permalink":"https://www.mechdancer.org/mechdancerlib/","excerpt":"","text":"Abstractmechdancerlib is a FTC robot library written by Kotlin. It provides structurize device tree of the robot, including the encapsulation and dispatching, which make program easier to use. MotivationFTC Control System has kept out of the category of embedded development, thus it’s very friendly to people who is new to programming, however, the usability of it is not good enough. For example: 1234567891011121314151617181920212223242526272829303132333435363738abstract class UnicornBaseOpMode : OpMode() &#123; protected lateinit var dumperArm: DCMotor private lateinit var dumperPushRod: Servo private lateinit var dustpan: Servo protected lateinit var collectorArm: DCMotor protected lateinit var collectorIntake: CRServo protected lateinit var expanderMotor: Motor protected lateinit var expanderLock: Servo protected lateinit var lifterTouch: RevTouchSensor protected lateinit var lifter: DCMotor override fun init() &#123; lifterTouch = hardwareMap.get(...) lifter = hardwareMap.get(...) collectorArm = hardwareMap.get(...) collectorIntake = hardwareMap.get(...) expanderMotor = hardwareMap.get(...) expanderLock = hardwareMap.get(...) dustpan = hardwareMap.get(...) dumperPushRod = hardwareMap.get(...) dumperArm = hardwareMap.get(...) &#125; override fun loop() &#123; ... &#125; override fun stop() &#123; ... &#125;&#125; Pay attention to init(), all devices attached to this robot which defined in one class (although it’s abstract), should be bind through hardwereMap. Those devices are flattened in program, and it’s not easy to use or manage. Therefore, we defined a thing called Structure, we can distinctly layered the program the robot through combining many structures. This is a part of our teleop: 123456789101112131415161718192021222324with(robot) &#123; //Chassis chassis.descartes &#123; x = master.leftStick.y y = master.leftStick.x w = 0.7 * master.rightStick.x &#125; //Helper expander.expandState = when &#123; helper.up.bePressed() -&gt; Expanding helper.down.bePressed() -&gt; Shrinking else -&gt; Expander.ExpandState.Stop &#125; expander.lockState = when &#123; helper.left.isPressing() -&gt; Lock helper.right.isPressing() -&gt; Unlock else -&gt; expander.lockState &#125; collector.armState = when &#123; helper.leftStick.y &gt; 0.5 -&gt; Lifting helper.leftStick.y &lt; -0.5 -&gt; Dropping else -&gt; Collector.ArmState.Stop &#125;&#125; Control details of devices are hidden, outer user should only focus on the whole robot control logic. OverviewTerminology A structure — is an specific definition of a robot part, like a rocker arm or a chassis. Once it is attached to robot as substructure, it will has a similar life-cycle. A monomeric structure — is a kind of structure which does not have substructure. All real devices are monomeric structures because they can’t have childes. A composite structure — a structure that have substructures. For example, a mecanum chassis is a composite structure which has four motors as substructure. Robot — is a unique composite structure, all structures are attached to it. Structure interface and classes123456789interface Structure &#123; val name: String fun run() override fun toString(): String &#125; This is a simple structure definition. It has a name, can be to string. run() function defines what this structure should do when robot is running. 12345abstract class MonomericStructure(override val name: String) : Structureabstract class CompositeStructure(override val name: String) : Structure &#123; abstract val subStructures: List&lt;Structure&gt;&#125; The only difference between a composite structure and a monomeric structure is that a composite structure can have substructures attached to it. DeviceDevice is a core of control system. Encapsulations done by FIRST are almost perfect, however, the only drawback is that the output and input data range are not unified. On the basis of correcting this, we create wrappers to let devices adapt this library. Furthermore, we high abstract the behavior of devices to make control more pure. We split devices which only perform output into effector, others into sensor. EffectorsMotor12345678910111213interface Motor : Structure &#123; var power: Double var direction: Direction override var lock: Boolean enum class Direction(internal val sign: Int) &#123; FORWARD(+1), REVERSE(-1); &#125;&#125; An user who control this motor should only notice the power and direction (ignore lock for the moment), implementing details is not important. The range of power is from -1.0 to 1.0. Continuous Servo1234567interface ContinuousServo : Structure &#123; var power: Double var pwmOutput: Boolean &#125; The only difference from motor is that it’s a pwm controlled device, whose output can be shutdown. The range of power is from -1.0 to 1.0. Servo1234567interface Servo : Structure &#123; var position: Double var pwmOutput: Boolean &#125; It is a pwm device having a position output. The range of position depends on device configuration. The unit of position is $rad$, which you have to specified in configuration. SensorsEncoder123456789interface Encoder : Structure &#123; val position: Double val speed: Double fun reset(off: Double)&#125; We separate the encoder from the motor. We believe that motors and encoders should be independent. This is a fly in the ointment in FIRST design. Certainly, they bind to a same DCMotor in low-level code. The unit of position is $rad$, speed is $rad/s​$. Touch Sensor1234567891011interface TouchSensor : Structure &#123; val force: Double fun bePressed(): Boolean fun isPressing(): Boolean fun isReleasing(): Boolean &#125; bePressed() returns the current state of button, isPressing() returns true when the first time the button be pressed, isReleasing() is similar to isPressing(). We process Gamepad in the same way, please see Gamepad. Color Sensor1234567891011121314interface ColorSensor : Structure &#123; val colorData: ColorData var enableLed: Boolean data class ColorData( val red: Int, val green: Int, val blue: Int, val alpha: Int, val argb: Int) &#125; Voltage Sensor12345interface VoltageSensor : Structure &#123; val voltage: Double &#125; Pre-cast structuresWe provides following common structures: Motor with encoderAs mentioned before, we divide the Motor and the Encoder into two parts according to their behavior. Although this is reasonable, in some cases it brings a lot of inconvenience. Therefore, a combination of motor and encoder is established. It is a CompositeStructure, have two substructures: a motor and a encoder. Through the combination of two devices, some new behaviors come out. At the beginning of the design, we thought for a long time whether this class should be polymorphic. In other word, can MotorWithEncoder be cast to Motor or Encoder? i.e. have the behaviors of both of the above. That sounds right, but it’s a special case. Think about it: can a mechanical arm with only one motor be counted as a motor? Actually, it is the pure combination of the two devices, and it just has the behavior of the two that makes polymorphism reasonable. And actually that’s wrong. However for the sake of constraint its functions, we let it inherit class Motor and Encoder, let its substructures work as delegates. Let’s see some details: 12345678910111213141516interface MotorWithEncoder : Motor, Encoder, Structure &#123; var mode: Mode var targetSpeed: Double var targetPosition: Double override var lock: Boolean enum class Mode &#123; SPEED_CLOSE_LOOP, OPEN_LOOP, POSITION_CLOSE_LOOP,STOP &#125;&#125; What behaviors mentioned above are that this combination has kinds of abilities to close-loop-control. ChassisChassis plays an important part of robot, so we provide basic definition of this structure: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class Chassis(motorsConfig: Array&lt;Pair&lt;String, Motor.Direction&gt;&gt;, enable: Boolean) : CompositeStructure(\"null_chassis\"), AutoCallable, SmartLogger &#123; override val subStructures: List&lt;Motor&gt; = motorsConfig.map &#123; MotorImpl(it.first, enable, it.second) &#125; open var powers = DoubleArray(motorsConfig.size) &#123; .0 &#125; get() = field.standardizeBy(maxPower) set(value) &#123; if (value.size != field.size) warn(\"Illegal size powers: $&#123;value.size&#125; ≠ $&#123;field.size&#125;\") else field = value &#125; var maxPower = 1.0 set(value) &#123; if (value !in -1.0..1.0) warn(\"Illegal max power: $maxPower ∉ [-1,1]\") else field = value &#125; /** * Standardizes powers * * If the input power has a value greater than the input maximum constraint, * the maximum is adjusted to the constraint value, * and the other values are scaled down. * * @param maxPower maximum power constraint ∈ [-1,1] */ private fun DoubleArray.standardizeBy(maxPower: Double) = map(::abs).max()!!.let &#123; if (it &lt;= abs(maxPower)) maxPower.sign else maxPower / it &#125;.let &#123; DoubleArray(size) &#123; i -&gt; this[i] * it &#125; &#125; override fun run() &#123; subStructures.forEachIndexed &#123; index: Int, motor: Motor -&gt; motor.power = powers[index] &#125; &#125;&#125; As you’ve seen, chassis is a structure managing some motors assembly, which provide ability to process relationship between motors, including standardize. Therefore, is provided farther: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class Omnidirectinal(motorsConfig: Array&lt;Pair&lt;String, Motor.Direction&gt;&gt;, enable: Boolean) : Chassis(motorsConfig, enable) &#123; /** * Descartes control parameters */ data class Descartes(var x: Double, var y: Double, var w: Double) &#123; operator fun times(other: Descartes) = Descartes(x * other.x, y * other.y, w * other.w) &#125; /** * Polar control parameters */ data class Polar(var rho: Double = .0, var theta: Double = .0, var omega: Double = .0) &#123; val block: Descartes.() -&gt; Unit = &#123; x = rho * cos(theta) y = rho * sin(theta) w = omega &#125; &#125; /** * Tank control parameters */ data class TankMode(var left: Double = .0, var right: Double = .0, var horizon: Double = .0) &#123; val block: Descartes.() -&gt; Unit = &#123; x = left + right y = horizon w = left - right &#125; &#125; /** * Transforms descartes parameters to powers of each wheel. */ protected abstract fun Descartes.transform(): DoubleArray override fun run() &#123; if (!advancedControlMode) powers = (weights * descartes).transform() super.run() &#125;&#125; Omnidirectinal is a kind of omni-directional mobile in cartesian coordinate system, there are three methods to control it, including Descartes, TankMode, and Polar. Notice that subclass need to declare motors and transform which describes how to drive this chassis. For convenience, drive way of mecanum chassis is built-in. 12345678910111213141516171819202122open class Mecanum(override val name: String = \"chassis\", enable: Boolean, lfMotorDirection: Motor.Direction = Motor.Direction.REVERSE, lbMotorDirection: Motor.Direction = Motor.Direction.REVERSE, rfMotorDirection: Motor.Direction = Motor.Direction.FORWARD, rbMotorDirection: Motor.Direction = Motor.Direction.FORWARD, lfMotorName: String = \"LF\", lbMotorName: String = \"LB\", rfMotorName: String = \"RF\", rbMotorName: String = \"RB\") : Omnidirectinal(arrayOf( lfMotorName to lfMotorDirection, lbMotorName to lbMotorDirection, rfMotorName to rfMotorDirection, rbMotorName to rbMotorDirection), enable) &#123; override fun Descartes.transform() = doubleArrayOf( +x + y - w, +x - y - w, +x - y + w, +x + y + w)&#125; Consequently, there is no need for you to write duplicated code anymore. RobotStructure tree is the core of this library, every node of which is a structure. The foregoing implies that all devices have become monomeric structure which don’t have substructures. Robot is the root of this tree, middleware structures we defined are leaves under the robot, devices are at the lowest nodes. Therefore, parent nodes just need to manage theirs sons, call run() of them. Because of the transitivity, robot is the parent of all structures. Lets see an example: 123456789101112131415161718192021222324252627class DummyRobot : Robot( \"dummyRobot\", Mecanum(enable = true), DummyArm(), DeviceFactory.colorSensor(\"colorSensor\") &#123; enable = true &#125;) &#123; @Inject lateinit var colorSensor: ColorSensor @Inject lateinit var voltageSensor: VoltageSensor @Inject(\"mecanumChassis\") lateinit var chassis: Mecanum @Inject private lateinit var dummyArm: DummyArm var armState: DummyArm.ArmState = DummyArm.ArmState.DOWN override fun run() &#123; dummyArm.armState = armState &#125;&#125; Substructures’ instantiation are provided via the constructor of Robot, and are used through Inject. You may think that it’s redundant that constructing a structure on your own but which can’t be a member of parent structure. In this case, substructures are created by your self, however, you can’t manage the life cycle of a structure frequently. Op ModeOp mode is the entry point of whole robot control program. All thins we can do are based on op mode, and it has a hardwareMap providing us a easy why to control device interfaces. Since we have our robot, we can write our op mode. Devices are bind to theirs corresponding structure wrappers in init, robot’s run() is called in loop. We do something quite import, so we ban the overriding of life cycle call back functions and provide new methods to let user to override: 1234567891011121314151617abstract class BaseOpMode&lt;T : Robot&gt; : OpModeWithRobot&lt;T&gt;() &#123; protected val robot: T = createRobot() ... abstract fun initTask() open fun initLoopTask() &#123;&#125; open fun startTask() &#123;&#125; abstract fun loopTask() abstract fun stopTask()&#125; Notice at robot, BaseOpMode have a generic parameter T:Robot, which means robot instance can be constructed through its type. However, we have to ensure that robot class can’t be abstract and muse have a public constructor without parameters. GamepadLet’s see the definition in robot core: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Gamepad &#123; public float left_stick_x = 0f; public float left_stick_y = 0f; public float right_stick_x = 0f; public float right_stick_y = 0f; public boolean dpad_up = false; public boolean dpad_down = false; public boolean dpad_left = false; public boolean dpad_right = false; public boolean a = false; public boolean b = false; public boolean x = false; public boolean y = false; public boolean start = false; public boolean back = false; public boolean left_bumper = false; public boolean right_bumper = false; public boolean left_stick_button = false; public boolean right_stick_button = false; public float left_trigger = 0f; public float right_trigger = 0f; &#125; FIRST provides a convenient way to let us use gamepad directly, however, there are some little problems: Buttons and joysticks lie in one class flatly, float and double members mix together. Joysticks have reversed vertical axis. The way to realize pressing a button only one time (even keep pressing) to execute some actions one time (e.g. when user press x button, a motor should start to run, etc.) really make people confused. Thus, we create few classes to reach better encapsulation. Button12345678910111213141516class Button : IGamePadComponent&lt;Boolean&gt; &#123; private var last = false fun bePressed() = raw fun isPressing() = !last &amp;&amp; bePressed() fun isReleasing() = last &amp;&amp; !bePressed() override var raw: Boolean = false set(value) &#123; last = field field = value &#125;&#125; As you see, bePressed() returns the current state of the button, while you keep pressing, isPressing() returns true only one time, isReleasing() returns true when you stop pressing. Stick1234567891011121314151617181920212223242526272829303132class Stick : IGamePadComponent&lt;DoubleArray&gt; &#123; val x get() = raw[0] val y get() = raw[1] val theta get() = Math.atan2(y, x) val radius get() = sqrt(x * x + y * y) var feel = 1.0 var diedArea = .0 private fun mapExpression(x: Double, f: Double) = (f / ((1 - f) * (x + 1) + f) - f) / (f - 1) private fun nonlinearMap(x: Double, feel: Double, diedArea: Double) = when &#123; Math.abs(x) &lt; diedArea -&gt; .0 feel == 1.0 -&gt; x x &lt; 0 -&gt; mapExpression(x, feel) else -&gt; -mapExpression(-x, feel) &#125; override var raw: DoubleArray = doubleArrayOf(.0, .0) set(value) &#123; field = doubleArrayOf( nonlinearMap(value[0], feel, diedArea), nonlinearMap(-value[1], feel, diedArea)) &#125;&#125; We provides a feel represents tactile coefficient, hence, the stick data will be more smooth. Besides, we reversed back y axis. Trigger123456789101112131415var pressingThreshold = 0.7 private var last = false fun bePressed() = raw &gt; pressingThreshold fun isPressing() = !last &amp;&amp; bePressed() fun isReleasing() = last &amp;&amp; !bePressed() override var raw: Double = .0 set(value) &#123; last = field &gt; pressingThreshold field = value &#125; Usually, triggers are used as button is very common, so we add a pressingThreshold to make it become to a button. Overall12345678910111213141516171819202122class Gamepad &#123; val leftBumper = Button() val rightBumper = Button() val a = Button() val b = Button() val x = Button() val y = Button() val up = Button() val down = Button() val left = Button() val right = Button() val leftStick = Stick() val rightStick = Stick() val leftTrigger = Trigger() val rightTrigger = Trigger() &#125; SampleLet’s see a part of our robot: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Dustpan : AbstractStructure( \"dustpan\", &#123; servo(\"servo\") &#123; origin = .0 ending = PI enable = true &#125;&#125;), Resettable &#123; @Inject private lateinit var servo: Servo @Volatile private var isBusy = false var state: State by Delegates.observable(State.Down) &#123; _, _, value -&gt; servo.position = when (value) &#123; State.Up -&gt; DUSTPAN_UP_RAD State.Down -&gt; DUSTPAN_DOWN_RAD &#125; &#125; fun dump(times: Int) &#123; if (isBusy) return isBusy = true GlobalScope.launch &#123; repeat(times) &#123; state = State.Up delay(DUSTPAN_RUNNING_DELAY) state = State.Down delay(DUSTPAN_RUNNING_DELAY) &#125; isBusy = false &#125; &#125; enum class State &#123; Up, Down &#125; override fun reset() &#123; state = State.Down &#125; override fun toString(): String = \"$&#123;javaClass.simpleName&#125; | State: $state\"&#125; It is called Dustpan, which is driven by a 180° servo. According the design of library, dustpan is a structure, having device servo as its substructure. Then we abstract two state of this part — Up and Down, which represent two position of servo. For easy to modify parameters and reduce coupling, DUSTPAN_UP_RAD and DUSTPAN_DOWN_RAD lie in other file. Outside can change the value of variable state to change the real state of this robot part. 1234567891011class UnicornRobot : Robot( \"unicorn_robot\", ... Dustpan(), ...) &#123; ... @Inject lateinit var dustpan: Dustpan&#125; We have to add it as substructure of robot mentioned before. Since then, we can write a teleop to control it: 12345678910111213class UnicornRemote : RemoteControlOpMode&lt;UnicornRobot&gt;() &#123; ... override fun loop(master: Gamepad, helper: Gamepad)&#123; //Master if (helper.y.isPressing()) robot.dustpan.dump(1) when &#123; master.y.bePressed() -&gt; robot.dustpan.state=State.Up master.b.bePressed() -&gt; robot.dustpan.state=State.Down &#125; &#125; ...&#125;","categories":[],"tags":[]},{"title":"Slf4j-RobotLog","slug":"slf4j-robotLog","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"slf4j-robotLog/","link":"","permalink":"https://www.mechdancer.org/slf4j-robotLog/","excerpt":"","text":"AbstractSlf4j-robotlog is a binder for the slf4j logger interface version 1.7 for FTC robot programming. It can convert the output of some libraries through the slf4j log interface to RobotLog output. MotivationIn the Java ecosystem, many library logs are used slf4j interface. But the logger provided in FTC programming is RobotLog, which also provides the ability to save the dump log to a file when the Op mode ends. However slf4j is just a specification of a logger without implementation. Common implementation in web programming is log4j, used by slf4j through a binder. slf4j will look for binders’implementation in the classpath at runtime. The binder uses log4j as the wrapper to implement the slf4j convention interface. Similarly, we use RobotLog as the wrapper to implement slf4j specification. UsageJust add this dependency to your project, all slf4j logs will perfectly output.","categories":[],"tags":[]},{"title":"Standalone TC","slug":"standalonetc","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"standalonetc/","link":"","permalink":"https://www.mechdancer.org/standalonetc/","excerpt":"","text":"AbstractStandalone tc is a simple implementation of the concept of responsive robot control system development. In robot programming, in most cases, the sensor is read in the loop and the current is output to the device. Such a program structure is not friendly to development because there must be coupling between instructions and controls. Reactive system can avoid all problems, although the bottom layer is still looping through the driver. Standalone tc is divided into three parts: host - upper-level responsive dependencies, slave - lower-level controller communication, protocol - upper-lower and lower-level communication protocols. Among them dataflow is responsible for the establishment of the upper layer responsive network. In addition, host provides tools for managing relationships between components from dependency. Like its name Standalone, its purpose is to build a reactive robot control system that is not specific to a development platform. Therefore, when you change the platform, you only need to modify the implementation to the lower layer. We implemented this architecture first on FTC, so slave is the FTCRobotController App. OverviewTerminology Effector — is a device that is only responsible for output, and its data node is target. Sensor — is a device that is only responsible for input, and its data node is source. Robot — is a dynamic scope, can load components. Robot component — is a special component with init and stop lifecycles. EffectorThe data node of all Effector types is OutputDriver&lt;T&gt;, which can be passed to the next node periodically when receiving data in the dataflow. Effector data nodes in the link should be the last end, and it will communicate to the network even when the robot starts. Let’s see most common effectors. Motor1234567891011121314151617181920class Motor(name: String, private val direction: Direction = Direction.FORWARD) : NamedComponent&lt;Motor&gt;(name), Device, PowerOutput &#123; override val power = OutputDriver&lt;Double&gt; &#123; raw -&gt; raw.checkedValue(-1.0..1.0)?.let &#123; it * direction.sign &#125; ?: logger.warning(\"Invalid motor power value: $raw\").run &#123; null &#125; &#125; override fun toString(): String = \"$&#123;javaClass.simpleName&#125;[$name]\" enum class Direction(val sign: Double) &#123; FORWARD(1.0), REVERSED(-1.0) &#125; override fun stop() &#123; power.close() &#125;&#125; Motor has a data node power. Servo12345678910111213141516class Servo(name: String, range: ClosedFloatingPointRange&lt;Double&gt;) : NamedComponent&lt;Servo&gt;(name), Device, PositionOutput, PwmOutput &#123; private val mapper = Lens(-1.0, 1.0, range.start, range.endInclusive) override val position: OutputDriver&lt;Double&gt; = OutputDriver &#123; raw -&gt; raw.checkedValue(range)?.let &#123; mapper(it) &#125; ?: logger.warning(\"Invalid servo position: $raw\").run &#123; null &#125; &#125; override val pwmEnable: OutputDriver&lt;Boolean&gt; = OutputDriver() override fun toString(): String = \"$&#123;javaClass.simpleName&#125;[$name]\"&#125; Servo has two data nodes: position and pwmEnable. SensorAll Sensors are source nodes. When a sensor value is updated in network communication, data is placed in its data node. It should be the starting point in the link. Let’s look at the most common sensors. Encoder12345678910111213141516171819202122class Encoder(name: String, cpr: Double = 360.0) : NamedComponent&lt;Encoder&gt;(name), Sensor&lt;EncoderData&gt; &#123; private val value = AtomicReference(EncoderData(.0, .0)) private val ratio = 2 * PI / cpr /** Current position */ val position get() = value.get().position /** Current speed */ val speed get() = value.get().speed override val updated: ISource&lt;EncoderData&gt; = broadcast() override fun update(new: EncoderData) &#123; val transformed = EncoderData(position * ratio, speed * ratio) if (value.getAndSet(transformed) != transformed) updated tryPost transformed &#125; override fun toString(): String = \"$&#123;javaClass.simpleName&#125;[$name]\"&#125; It can be seen that in addition to the reactive flow of data, it also stores the last data for combined time operations. RobotAll devices are component, the robot is a dynamic scope, so the device can be setup to the bot. As mentioned in the dependency article, there may be some composite components in the robot that can rely on instances of the device. The robot initializes the RobotComponent in it when it initializes and configures the connection between the network communication and the dataflow. Use caseLet’s see teleop program: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374object RemoteControl : RobotProgram&lt;UnicornRobot&gt;() &#123; private val master = robot.master private val helper = robot.helper override fun init() &#123; //Chassis master.updated - &#123; MecanumChassis.Descartes( it.leftStickY, it.leftStickX, -it.rightStickX ) &#125; - robot.chassis.descartesControl //Expander //Helper up: Expanding/Stop helper.up.pressing - &#123; Expander.State.Expanding &#125; - Expander.state helper.up.releasing - &#123; Expander.State.Stop &#125; - Expander.state //Helper down: Shirking/Stop helper.down.pressing - &#123; Expander.State.Shrinking &#125; - Expander.state helper.down.releasing - &#123; Expander.State.Stop &#125; - Expander.state //Helper left and right: Lock/Unlock helper.left.pressing - &#123; true &#125; - Expander.lock helper.right.pressing - &#123; false &#125; - Expander.lock //Collector //Helper left stick: Lifting/Dropping/Stop helper.leftStick.valueChanged - &#123; when &#123; it.y &gt; 0.5 -&gt; Collector.ArmState.Lifting it.y &lt; -0.5 -&gt; Collector.ArmState.Dropping else -&gt; Collector.ArmState.Stop &#125; &#125; - Collector.arm //Helper right trigger: Collecting/Stop helper.rightTrigger.pressing - &#123; Collector.CollectorState.Collecting &#125; - Collector.core helper.rightTrigger.releasing - &#123; Collector.CollectorState.Stop &#125; - Collector.core //Helper left bumper: Spiting/Stop helper.leftBumper.pressing - &#123; Collector.CollectorState.Spiting &#125; - Collector.core helper.leftBumper.releasing - &#123; Collector.CollectorState.Stop &#125; - Collector.core //Dumper TODO: Arguments //Master right bumper: Pushes rod 2 times master.rightBumper.pressing - &#123; 2 &#125; - Dumper.pushRod master.y.pressing - &#123; 0.35 + if (Dumper.inSadArea) 0.2 else .0 &#125; - Dumper.power master.y.releasing - &#123; .0 &#125; - Dumper.power master.a.pressing - &#123; 0.5 + if (Dumper.inSadArea) 0.2 else .0 &#125; - Dumper.power master.b.releasing - &#123; .0 &#125; - Dumper.power //Helper y: Enable dumper lock helper.y.pressing linkTo &#123; Dumper.lockEnable = !Dumper.lockEnable &#125; //Lifter //When master left trigger is pressed, robot lands to ground //Presses right trigger to interrupt master.leftTrigger.pressing - &#123; Lifter.State.Landing &#125; - Lifter.state master.rightTrigger.pressing - &#123; if (Lifter.lastState == Lifter.State.Landing) Lifter.State.Stop else Lifter.State.Lifting &#125; - Lifter.state master.rightTrigger.releasing - &#123; Lifter.State.Stop &#125; - Lifter.state //Dustpan //Master left bumper: dumps 1 time master.leftBumper.pressing - &#123; 1 &#125; - Dustpan.dump &#125;&#125; We should configure the link relationship when init. As shown in the snippet, when the gamepad1 value is updated, the remote sensing data is wrapped into a chassis speed vector and then flows into the descartes controller node of the chassis. When the button up of gampad2 is pressed, the state Expanding will flow into state of Expander. Because it is a remote control program, most of the links source are handles.","categories":[],"tags":[]},{"title":"State machine","slug":"statemachine","date":"9102-01-01T00:00:00.000Z","updated":"2019-04-14T07:00:00.491Z","comments":true,"path":"statemachine/","link":"","permalink":"https://www.mechdancer.org/statemachine/","excerpt":"","text":"Abstractstate machine is a light-weight tool facilitate autonomous programming. It provides capability of collaborative working in single thread driven through loop. Thread safety is not supported. MotivationTypically, a op mode will be like this: 123456789101112class DemoOpMode : BaseOpMode&lt;UnicornRobot&gt;() &#123; override fun initTask() &#123; &#125; override fun loopTask() &#123; &#125; override fun stopTask() &#123; &#125;&#125; As for BaseOpMode, it’s a encryption of OpMode, which you can find in mechdancerlib. Notice that the main logic we should write will be in loopTask(), which called circularly. For example, there is a simple requirement: robot moves forward for one second, then uses locator to move to a (5,5). Think about this process, it’s kind of a action chain, including delay and close-loop control. Those two are time-consuming procedures, as they ought to work in a loop. However, there is a problem that how to ensure that two actions can be run precisely in loop. Obviously, blocking the thread is not allowed, it’s the key that loop control structure should be converted to linear actions. Let’s see the implementation of the requirement mentioned above through linear state machine: 1234567891011demoLinearStateMachine .add &#123; robot.chassis.descartes &#123; x = 1.0 y = .0 w = .0 &#125; NEXT &#125; .add(Delay(1000)) .add(PIDMove(vector3DOf(0, 0, 0), .1, 0.2)) What needs to be done next is calling the invoke() of the state machine in loop: 123override fun loopTask() &#123; demoLinearStateMachine()&#125; Actions are described as transfer of states via state machine, so that they can be run correctly in loop. OverviewPrimitives123typealias StateMember&lt;T&gt; = (() -&gt; T)typealias StateMachine = StateMember&lt;Boolean&gt; StateMember&lt;T&gt; is a alias of (() -&gt; T), which is lambda without parameter, return type T. In other words, arbitrary such lambda can be seen as a state. StateMachine is StateMember&lt;Boolean&gt;, a specific state, returning if this state machine is finished. 12345const val FINISH = trueconst val CONTINUE = falseconst val NEXT = trueconst val REPEAT = false FINISH and CONTINUE mark if state machine should switch state, NEXT and REPEAT mark if one state is finished. As you seen, all primitive definitions are typealias or const val, thus cost of running can be reduced. Operations12345678910111213141516171819infix fun &lt;T&gt; StateMember&lt;*&gt;.join(other: StateMember&lt;T&gt;): StateMember&lt;T&gt; = &#123; this(); other() &#125;operator fun StateMachine.plus(other: StateMachine): StateMachine = &#123; val a = this() val b = other() a || b&#125;operator fun StateMachine.times(other: StateMachine): StateMachine = &#123; val a = this() val b = other() a &amp;&amp; b&#125;fun &lt;T&gt; StateMember&lt;T&gt;.run(): T? = invoke()fun StateMachine.runToFinish() &#123; while (run() == CONTINUE);&#125; join() can combine two linear members into one linearly. Binary operators + and * are similar to operators between Boolean:|| and &amp;&amp; correspondingly, which mean that when either this or other finish continue, when both this and other finish continue. runToFinish() will block current thread until state machine’s invoke returning true. State machinesFor easy to use, some preset state machine are provided: LinearStateMachine LinearStateMachineWithWatchDog RepeatingLinearStateMachine StepStateMachine StandardStateMachine Delay For more information please see below. Linear state machinesLinear state machine is a concept that running states sequentially. Even if there are few linear state machine definitions provided, they don’t have any superclass or interface contracting. They are named in this way due to the fact that they have similar behaviors. 1234567891011open class LinearStateMachine : StateMachine &#123; private val states: Queue&lt;StateMember&lt;Boolean&gt;&gt; = LinkedList&lt;StateMember&lt;Boolean&gt;&gt;() fun add(state: StateMember&lt;Boolean&gt;): LinearStateMachine = apply &#123; states.offer(state) &#125; override fun invoke(): Boolean &#123; val current = states.peek() if (current != null &amp;&amp; run(current) == NEXT) states.poll() return if (states.peek() == null) NEXT else REPEAT &#125; Common linear state machine add state members into a internal queue simply, and poll state member from queue when state machine is running. 12345678910open class LinearStateMachineWithWatchDog : StateMachine &#123; private val driver = LinearStateMachine() fun add(state: StateMember&lt;Boolean&gt;, timeout: Long): LinearStateMachineWithWatchDog = apply &#123; driver.add(state + Delay(timeout)) &#125; override fun invoke() = driver()&#125; The only difference from common linear state machine is that each state member has a time limit, which let state machine transfer when it’s timeout. 1234567891011121314open class RepeatingLinearStateMachine : StateMachine &#123; private val states: MutableList&lt;StateMember&lt;Unit&gt;&gt; = mutableListOf() private var index = 0 fun add(state: StateMember&lt;Unit&gt;): RepeatingLinearStateMachine = apply &#123; states.add(state) &#125; override fun invoke(): Boolean &#123; if (states.isEmpty()) return FINISH states[index++]() index %= states.size return if (0 == index) FINISH else CONTINUE &#125;&#125; Repeating linear state machine is a special linear state machine, which do not discard states when that is finished, will run state members in loop. Step state machineStep state machine doesn’t save state members, because current running state member will return state member to run later. 1234567class StepStateMachine(private var current: StateMember&lt;StateMember&lt;*&gt;?&gt;?) : StateMachine &#123; override fun invoke(): Boolean &#123; @Suppress(\"UNCHECKED_CAST\") current = current?.invoke() as StateMember&lt;StateMember&lt;*&gt;?&gt;? return if (current == null) FINISH else CONTINUE &#125;&#125; If current state returns null, state machine will finish. DelayUsually, delay plays an important role in control. Therefore, function delay are implemented through state machine as well. 123456789101112class Delay(delay: Long) : StateMachine &#123; private val timer = MyTimer(delay) private var waiting: StateMember&lt;StateMember&lt;*&gt;?&gt; = &#123; null &#125; init &#123; waiting = &#123; if (timer.isFinished) null else waiting &#125; &#125; private val driver = StepStateMachine &#123; timer.start(); waiting &#125; override fun invoke() = driver()&#125; Notice driver, the internal implementation of delay is a step state machine. waiting is a state member, returns null when time is up, itself otherwise. Actually this is a recursive lambda, step state machine uses such state member as mentioned before. Stellate12345678910111213class StellateStateMachine&lt;T&gt;(private val core: StateMember&lt;T&gt;) : StateMachine &#123; private val states = HashMap&lt;T, StateMember&lt;Unit&gt;&gt;() fun add(key: T, state: StateMember&lt;Unit&gt;): StellateStateMachine&lt;T&gt; = apply &#123; states[key] = state &#125; override fun invoke(): Boolean &#123; val currentKey = run(core) if (!states.containsKey(currentKey)) return FINISH states[currentKey]?.invoke() return CONTINUE &#125;&#125; Stellate state machine is unique because core will be run in every loop which returns the key to next common state. Common states can be add with a key using add().","categories":[],"tags":[]}]}